#!/bin/zsh
#########################################################################
# Copyright (C) 2014  Wojciech Siewierski                               #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################


help()
{
    <<EOF
Usage:
	$0 list     <tag>  [<tag>...] -- list files tagged with all of these tags
	$0 listany  <tag>  [<tag>...] -- list files tagged with any of these tags
	$0 show     <file>            -- list tags associated with a file
	$0 tag[+|-] <file> [<tag>...] -- add, remove or overwrite a tag list associated with a file

Common options:
    $0 [ -d <directory> ] ...     -- custom database directory (default: ~/.plaintag)
EOF
}

while getopts "d:" ARG; do
    case "$ARG" in
        d)
            TAGDIR=$OPTARG ;;
        ?)
            help; return 1 ;;
    esac
done
shift $[$OPTIND-1]


[[ -z $TAGDIR ]] && TAGDIR=$HOME/.plaintag
mkdir -p $TAGDIR


# associate a new tag with a file
add_tags()
{
    local file tag

    file=$1
    if ! shift 2> /dev/null; then
        help
        return 1
    fi

    for tag in $TAGDIR/$^argv; do
        touch $tag
        echo $file:a | sort --output=$tag --merge --unique -- - $tag
    done
}

# disassociate a tag with a file
rm_tags()
{
    local file

    file=$1
    if ! shift 2> /dev/null; then
        help
        return 1
    fi

    if [[ -n $argv ]]; then
        perl -ni -e '
        BEGIN {
            $file = shift;
            @tags = @ARGV;
        }
        print "$_" if $_ ne "$file\n";
        END {
            unlink for grep {-z $_} @tags
        }' $file:a $TAGDIR/$^argv 2> /dev/null
    fi
}

# show tags associated with a file
show_tags()
{
    local file all_tags

    file=$1:a
    if ! shift 2> /dev/null; then
        help
        return 1
    fi

    pushd -q $TAGDIR
    all_tags=(*(N))
    if [[ -n $all_tags ]]; then
        grep --fixed-strings --line-regexp --files-with-matches -- $file $all_tags 2> /dev/null
    fi
    popd -q
}

# list files with any of the given tags
list_tagged_any()
{
    local tags

    pushd -q $TAGDIR
    tags=(*(N))
    tags=(${tags:*argv})        # get only the existing tags
    if [[ -n $tags ]]; then
        < $tags | sort --unique
    fi
    popd -q
}

# list files with all of the given tags
list_tagged()
{
    local tag tags files tmp

    pushd -q $TAGDIR
    all_tags=(*(N))
    # do nothing if any of these tags does not exist or if the list is empty
    if [[ -n ${argv:|all_tags} || -z $argv ]]; then
        return
    fi
    tag=$1
    shift
    IFS=$'\n'
    files=($(< $tag))
    for tag in $argv; do
        tmp=($(< $tag))
        files=${files:*tmp}
    done
    unset IFS
    popd -q
    print -l $files
}

# overwrite the file's current tags with a new set of tags
set_tags()
{
    local file new_tags current_tags tags_to_add tags_to_remove

    file=$1
    if ! shift 2> /dev/null; then
        help
        return 1
    fi

    IFS=$'\n'
    new_tags=($argv)
    current_tags=($(show_tags $file))
    tags_to_add=(${new_tags:|current_tags})
    tags_to_remove=(${current_tags:|new_tags})
    unset IFS

    add_tags $file $tags_to_add
    rm_tags $file $tags_to_remove
}


cmd=$1
if ! shift 2> /dev/null; then
    help
    return 1
fi

case $cmd in
    --help|-h|help)
        help ;;
    list)
        list_tagged $argv ;;
    listany)
        list_tagged_any $argv ;;
    show)
        show_tags $argv ;;
    tag+)
        add_tags $argv ;;
    tag-)
        rm_tags $argv ;;
    tag)
        set_tags $argv ;;
    *)
        help; return 1 ;;
esac
